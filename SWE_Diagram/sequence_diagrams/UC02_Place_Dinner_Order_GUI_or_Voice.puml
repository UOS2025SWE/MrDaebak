@startuml
title "UC-02: Place Dinner Order - GUI or Voice"

actor customer as "Customer"
participant "fe:CustomerWebApp" as fe
participant "menuR:MenuRouter" as menuR
participant "checkoutR:CheckoutRouter" as checkoutR
participant "orderR:OrderRouter" as orderR
participant "voiceR:VoiceRouter" as voiceR
participant "orderSvc:OrderService" as orderSvc
participant "paySvc:PaymentService" as paySvc
participant "discSvc:DiscountService" as discSvc
participant "aiClient:AIClient" as aiClient
participant "redis:Redis" as redis
participant "aiWorker:AIWorker\n(AI Server)" as aiWorker
participant "whisperSvc:WhisperSTTService\n(AI Server)" as whisperSvc
participant "qwenSvc:QwenLLMService\n(AI Server)" as qwenSvc
actor paymentSystem as "Mock Payment"

== GUI Order Path ==
activate customer
customer -> fe: Select menu/style, customize,\nclick "Checkout"
deactivate customer
activate fe
fe -> checkoutR: POST /api/checkout/checkout\n(menu_code, style, quantity,\ncustomizations, side_dishes, cake, delivery, payment)
deactivate fe
activate checkoutR
checkoutR -> orderSvc: create_order(db, order_data)
activate orderSvc
orderSvc -> discSvc: calculate_order_pricing(user_id,\noriginal_price, db)\n(and persist order)
activate discSvc
discSvc --> orderSvc: pricing info
deactivate discSvc
orderSvc --> checkoutR: { success, order.id, pricing }
deactivate orderSvc

checkoutR -> paySvc: process_mock_payment(order_id,\namount, card_info, db)
activate paySvc
paySvc -> paymentSystem: authorize/charge
activate paymentSystem
paymentSystem --> paySvc: success / fail
deactivate paymentSystem
paySvc -> paySvc: persist payment & update\norder.payment_status
paySvc --> checkoutR: { success, payment_id, transaction_id }
deactivate paySvc

checkoutR --> fe: HTTP 200 { order_id, order_number,\npricing, payment_status }
deactivate checkoutR
activate fe
fe --> customer: Show order confirmation
deactivate fe

== Voice Order Path ==
group Capture & Transcribe (STT via AI Worker)
  activate customer
  customer -> fe: Press "Voice Order" & speak
  deactivate customer
  activate fe
  fe -> voiceR: POST /api/voice/stt\n(audio_bytes, filename, mime_type)
  deactivate fe
  activate voiceR
  voiceR -> aiClient: send_stt_request(audio_bytes, ...)
  activate aiClient
  aiClient -> redis: LPUSH ai:queue:stt\n(request_id, audio_data)
  activate redis
  redis -> aiWorker: BRPOP (monitor queue)
  activate aiWorker
  aiWorker -> whisperSvc: transcribe(audio_bytes, ...)
  activate whisperSvc
  whisperSvc --> aiWorker: transcript text
  deactivate whisperSvc
  aiWorker -> redis: PUBLISH ai:result:{request_id}\n(transcript)
  deactivate aiWorker
  redis --> aiClient: subscribe result
  deactivate redis
  aiClient --> voiceR: transcript text
  deactivate aiClient
  voiceR --> fe: transcript text
  deactivate voiceR
end

group Analyze & Recommend (LLM via AI Worker)
  activate fe
  fe -> voiceR: POST /api/voice/analyze\n(transcript, session_id, user_id)
  deactivate fe
  activate voiceR
  voiceR -> aiClient: send_llm_request(transcript, user_id, ...)
  activate aiClient
  aiClient -> aiClient: get_user_order_history(user_id, db)\nget_active_events(db)
  aiClient -> redis: LPUSH ai:queue:llm\n(request_id, transcript, context, history, events)
  activate redis
  redis -> aiWorker: BRPOP (monitor queue)
  activate aiWorker
  aiWorker -> qwenSvc: analyze_voice_order(transcript,\ncontext, user_history, events)
  activate qwenSvc
  qwenSvc -> qwenSvc: build_prompt(...)\ngenerate with vLLM
  qwenSvc --> aiWorker: structured JSON\n(intent, menu, style, qty,\ncustomizations, confidence)
  deactivate qwenSvc
  aiWorker -> redis: PUBLISH ai:result:{request_id}\n(analysis result)
  deactivate aiWorker
  redis --> aiClient: subscribe result
  deactivate redis
  aiClient --> voiceR: analysis + proposed order
  deactivate aiClient
  voiceR --> fe: AI response + order preview
  deactivate voiceR
  activate fe
  fe --> customer: Show recommended dinner\n(menu/style/qty/customization)
  deactivate fe
end

group Confirm & Create Order
  activate customer
  customer -> fe: Confirm AI-suggested order
  deactivate customer
  activate fe
  fe -> orderR: POST /api/orders\n(dinner_code, style, quantity,\ncustomizations, side_dishes, cake_customization)
  deactivate fe
  activate orderR
  orderR -> orderSvc: create_order(...)\n(persist order, reservations, pricing)
  activate orderSvc
  orderSvc --> orderR: { success, order.id, pricing }
  deactivate orderSvc
  orderR --> fe: 200 OK
  deactivate orderR
  activate fe
  fe --> customer: Show \"Order created\" and\nnavigate to confirmation
  deactivate fe
end

@enduml


