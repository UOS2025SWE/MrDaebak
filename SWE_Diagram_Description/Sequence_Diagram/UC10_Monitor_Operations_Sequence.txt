교류도: Monitor Operations & Handle Inquiries (MRD-CUS-UC10)

================================================================================

1. 교류: 운영 대시보드 조회 (주 흐름)

1) 매니저 (Manager) -> AdminAppUI (adminUI)
- 매니저가 '운영 대시보드(Operations Dashboard)' 페이지를 열어 실시간 운영 현황 확인

2) AdminAppUI (adminUI) -> OperationsRouter (opsR)
- AdminAppUI가 GET /api/operations/dashboard 엔드포인트로 대시보드 데이터 조회 요청을 전송
- 요청 헤더: Authorization: Bearer JWT 토큰

3) OperationsRouter (opsR) -> LoginService (loginSvc)
- OperationsRouter가 verify_token(JWT) 메서드를 호출하여 JWT 토큰 검증
- 매니저 권한 확인 (user_type=MANAGER)

4) LoginService (loginSvc) -> OperationsRouter (opsR)
- LoginService가 토큰 검증 결과 반환
- 반환 데이터: payload {user_id: string, user_type: MANAGER}
- 매니저 권한 확인 완료

5) OperationsRouter (opsR) -> OperationsRouter (opsR)
- OperationsRouter가 get_dashboard_metrics(db) 메서드를 호출하여 운영 지표 수집
- 수집 항목: 당일 주문 수, 진행 중인 주문, 완료된 주문, 취소된 주문, 총 매출액, 재고 부족 알림

6) OperationsRouter (opsR) -> PostgreSQL
- OperationsRouter가 여러 테이블에서 데이터를 집계
- orders 테이블: COUNT(*) GROUP BY order_status, SUM(total_price) WHERE created_at >= TODAY
- store_inventory 테이블: COUNT(*) WHERE quantity_on_hand <= reorder_level
- customer_inquiries 테이블: COUNT(*) WHERE status = 'NEW'
- staff_details 테이블: COUNT(*) WHERE is_on_duty = true

7) OperationsRouter (opsR) -> AdminAppUI (adminUI)
- 200 OK 상태 코드와 함께 대시보드 데이터를 반환
- 응답 데이터: {
  today_orders: number,
  orders_in_progress: number,
  completed_orders: number,
  total_revenue: number,
  low_stock_count: number,
  pending_inquiries: number,
  staff_on_duty: number
}

8) AdminAppUI (adminUI) -> 매니저 (Manager)
- AdminAppUI가 운영 지표를 대시보드 형식으로 화면에 렌더링
- 표시 정보: 주요 지표 카드(당일 주문 수, 진행 중 주문, 매출액), 차트(시간대별 주문 추이), 알림(재고 부족, 미처리 문의)
- 각 지표는 색상 코드로 시각화 (정상-녹색, 주의-주황색, 경고-빨간색)
- 실시간 업데이트를 위한 자동 새로고침 설정 (30초 간격)

================================================================================

2. 교류: 고객 문의 목록 조회 (주 흐름 및 부 흐름 2a)

1) 매니저 (Manager) -> AdminAppUI (adminUI)
- 매니저가 '고객 문의(Customer Inquiries)' 페이지를 열어 접수된 문의 확인

2) AdminAppUI (adminUI) -> InquiryRouter (inquiryR)
- AdminAppUI가 GET /api/inquiries/manage 엔드포인트로 문의 목록 조회 요청을 전송
- 요청 헤더: Authorization: Bearer JWT 토큰
- 쿼리 파라미터: status (선택적, 필터링용: NEW, IN_PROGRESS, RESOLVED)

3) InquiryRouter (inquiryR) -> LoginService (loginSvc)
- InquiryRouter가 verify_token(JWT) 메서드를 호출하여 JWT 토큰 검증
- 매니저 권한 확인

4) LoginService (loginSvc) -> InquiryRouter (inquiryR)
- LoginService가 토큰 검증 결과 반환
- 반환 데이터: payload {user_id: string, user_type: MANAGER}

5) InquiryRouter (inquiryR) -> InquiryService (inquirySvc)
- InquiryRouter가 list_inquiries(db, status_filter) 메서드를 호출하여 문의 목록 조회
- 필터링: status 파라미터가 있으면 해당 상태의 문의만 조회

6) InquiryService (inquirySvc) -> PostgreSQL
- InquiryService가 customer_inquiries 테이블에서 데이터 조회
- 조회 쿼리: SELECT * FROM customer_inquiries WHERE status = ? ORDER BY created_at DESC
- 조회되는 데이터: inquiry_id, name, email, topic, message, status, manager_note, created_at, updated_at

7) 교류 분기 (Alternative Flow):
- (부 흐름 2a) 문의 내역 없음 시:
- PostgreSQL이 빈 결과 집합을 반환 (문의 내역이 없음)
- InquiryService가 빈 배열 {inquiries: []}을 InquiryRouter로 반환
- InquiryRouter가 AdminAppUI로 200 OK와 함께 빈 배열을 반환
- AdminAppUI가 매니저에게 "현재 접수된 문의가 없습니다." 메시지를 표시
- 유즈케이스 종료

- (주 흐름) 문의 내역 존재 시:
- PostgreSQL이 문의 목록 데이터를 반환
- 다음 단계로 진행

8) InquiryService (inquirySvc) -> InquiryRouter (inquiryR)
- 문의 목록 조회 성공 응답 반환
- 응답 데이터: {inquiries: array}
- 각 문의 객체: inquiry_id, name, email, topic, message, status, manager_note, created_at

9) InquiryRouter (inquiryR) -> AdminAppUI (adminUI)
- 200 OK 상태 코드와 함께 문의 목록을 반환
- 응답 바디: {inquiries: [...]}

10) AdminAppUI (adminUI) -> 매니저 (Manager)
- AdminAppUI가 문의 목록을 화면에 렌더링
- 표시 정보: 고객 이름, 이메일, 주제, 메시지 요약, 상태, 접수 일시
- 상태별 색상 구분: NEW (빨간색), IN_PROGRESS (주황색), RESOLVED (녹색)
- 각 문의마다 '상세 보기' 및 '답변하기' 버튼 제공
- 필터링 옵션 제공: 전체, 신규, 처리 중, 완료

================================================================================

3. 교류: 고객 문의 답변 및 상태 업데이트 (주 흐름 및 부 흐름 4a)

1) 매니저 (Manager) -> AdminAppUI (adminUI)
- 매니저가 특정 문의의 '답변하기' 버튼을 클릭하여 답변 폼 열기

2) AdminAppUI (adminUI) -> 매니저 (Manager)
- AdminAppUI가 문의 상세 정보와 답변 입력 폼을 표시
- 표시 정보: 고객 이름, 이메일, 주제, 전체 메시지, 접수 일시, 현재 상태
- 입력 필드: 매니저 메모(manager_note), 상태 변경(status)

3) 매니저 (Manager) -> AdminAppUI (adminUI)
- 매니저가 답변 내용을 작성하고 상태를 변경 (예: NEW → RESOLVED)
- 입력 내용: 매니저 메모, 새 상태 (IN_PROGRESS 또는 RESOLVED)

4) AdminAppUI (adminUI) -> InquiryRouter (inquiryR)
- AdminAppUI가 PATCH /api/inquiries/{inquiry_id} 엔드포인트로 문의 업데이트 요청을 전송
- 요청 바디: {manager_note: string, status: string}
- 요청 헤더: Authorization: Bearer JWT 토큰

5) InquiryRouter (inquiryR) -> LoginService (loginSvc)
- InquiryRouter가 verify_token(JWT) 메서드를 호출하여 JWT 토큰 검증
- 매니저 권한 확인

6) LoginService (loginSvc) -> InquiryRouter (inquiryR)
- LoginService가 토큰 검증 결과 반환
- 반환 데이터: payload {user_id: string, user_type: MANAGER}

7) InquiryRouter (inquiryR) -> InquiryService (inquirySvc)
- InquiryRouter가 update_inquiry(db, inquiry_id, manager_note, status) 메서드를 호출하여 문의 업데이트
- 파라미터: 문의 ID, 매니저 메모, 새 상태

8) InquiryService (inquirySvc) -> PostgreSQL
- InquiryService가 customer_inquiries 테이블에서 해당 inquiry_id의 레코드를 UPDATE
- 업데이트되는 필드: manager_note, status, updated_at
- UPDATE customer_inquiries SET manager_note = ?, status = ?, updated_at = NOW() WHERE inquiry_id = ?

9) 교류 분기 (Alternative Flow):
- (부 흐름 4a) 문의 업데이트 실패 시:
- 데이터베이스 업데이트 중 오류 발생 (예: 연결 실패, 문의가 존재하지 않음)
- InquiryService가 InquiryRouter로 500 Internal Server Error 또는 404 Not Found 오류를 반환
- 오류 메시지: "문의 업데이트에 실패했습니다."
- InquiryRouter가 AdminAppUI로 오류 응답 전달
- AdminAppUI가 매니저에게 오류 메시지를 표시
- 흐름 (1)로 복귀

- (주 흐름) 업데이트 성공 시:
- UPDATE가 성공적으로 완료
- 다음 단계로 진행

10) InquiryService (inquirySvc) -> InquiryRouter (inquiryR)
- 문의 업데이트 성공 응답 반환
- 응답 데이터: {success: true, inquiry: {inquiry_id, status, manager_note, updated_at}}

11) InquiryRouter (inquiryR) -> AdminAppUI (adminUI)
- 200 OK 상태 코드와 함께 업데이트 성공 응답을 반환
- 응답 바디: {success: true, inquiry: {...}}

12) AdminAppUI (adminUI) -> 매니저 (Manager)
- AdminAppUI가 업데이트된 문의 정보를 UI에 반영
- 표시 정보: 새 상태, 매니저 메모, 업데이트 일시
- "문의가 업데이트되었습니다." 성공 메시지 표시
- 상태 배지 색상 업데이트 (예: 빨간색 → 녹색)
- 문의 목록으로 리디렉션 또는 다음 미처리 문의로 이동 옵션 제공
